|Mode         |Syntax          |Operator|len |time|Mnemonic Description                         |Category              |Extensive Description                      |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
|Immediate    |AND #$44        |$29    |2    |2   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand for calculation immediate.|
|Zero Page    |AND $44         |$25    |2    |3   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as zero page address. |
|Zero Page,X  |AND $44,X       |$35    |2    |4   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as zero page address plus X. |
|Absolute     |AND $4400       |$2D    |3    |4   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as address. |
|Absolute,X   |AND $4400,X     |$3D    |3    |4   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as address plus X. |
|Absolute,Y   |AND $4400,Y     |$39    |3    |4   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as address plus Y. |
|(Indirect,X) |AND ($44,X)     |$21    |2    |6   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as zero page address plus X. |
|(Indirect),Y |AND ($44),Y     |$31    |2    |5   |AND Bitwise AND with Accumulator             |Bitwise Instructions  |Take the operand as zero page address, add Y. |
|Immediate    |EOR #$44        |$49    |2    |2   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand for calculation immediate.|
|Zero Page    |EOR $44         |$45    |2    |3   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as zero page address.  |
|Zero Page,X  |EOR $44,X       |$55    |2    |4   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as zero page address plus X. |
|Absolute     |EOR $4400       |$4D    |3    |4   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as address. |
|Absolute,X   |EOR $4400,X     |$5D    |3    |4   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as address plus X. |
|Absolute,Y   |EOR $4400,Y     |$59    |3    |4   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as address plus Y. |
|(Indirect,X) |EOR ($44,X)     |$41    |2    |6   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as zero page address plus X. |
|(Indirect),Y |EOR ($44),Y     |$51    |2    |5   |EOR Bitwise Exclusive-OR with Accumulator    |Bitwise Instructions  |Take the operand as zero page address, add Y. |
|Immediate    |ORA #$44        |$09    |2    |2   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand for calculation immediate.|
|Zero Page    |ORA $44         |$05    |2    |3   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as zero page address.  |
|Zero Page,X  |ORA $44,X       |$15    |2    |4   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as zero page address plus X. |
|Absolute     |ORA $4400       |$0D    |3    |4   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as address. |
|Absolute,X   |ORA $4400,X     |$1D    |3    |4   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as address plus X. |
|Absolute,Y   |ORA $4400,Y     |$19    |3    |4   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as address plus Y. |
|(Indirect,X) |ORA ($44,X)     |$01    |2    |6   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand plus X as zero page address. |
|(Indirect),Y |ORA ($44),Y     |$11    |2    |5   |ORA Bitwise OR with Accumulator              |Bitwise Instructions  |Take the operand as zero page address, add Y to the contents.  |
|Accumulator  |ASL A           |$0A    |1    |2   |ASL Arithmetic Shift Left                    |Bitwise Instructions  |ASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Zero Page    |ASL $44         |$06    |2    |5   |ASL Arithmetic Shift Left                    |Bitwise Instructions  |ASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Zero Page,X  |ASL $44,X       |$16    |2    |6   |ASL Arithmetic Shift Left                    |Bitwise Instructions  |ASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Absolute     |ASL $4400       |$0E    |3    |6   |ASL Arithmetic Shift Left                    |Bitwise Instructions  |ASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Absolute,X   |ASL $4400,X     |$1E    |3    |7   |ASL Arithmetic Shift Left                    |Bitwise Instructions  |ASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Accumulator  |LSR A           |$4A    |1    |2   |LSR Logical Shift Right                      |Bitwise Instructions  |LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Zero Page    |LSR $44         |$46    |2    |5   |LSR Logical Shift Right                      |Bitwise Instructions  |LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Zero Page,X  |LSR $44,X       |$56    |2    |6   |LSR Logical Shift Right                      |Bitwise Instructions  |LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Absolute     |LSR $4400       |$4E    |3    |6   |LSR Logical Shift Right                      |Bitwise Instructions  |LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Absolute,X   |LSR $4400,X     |$5E    |3    |7   |LSR Logical Shift Right                      |Bitwise Instructions  |LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Accumulator  |ROL A           |$2A    |1    |2   |ROL Rotate Left                              |Bitwise Instructions  |ROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Zero Page    |ROL $44         |$26    |2    |5   |ROL Rotate Left                              |Bitwise Instructions  |ROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Zero Page,X  |ROL $44,X       |$36    |2    |6   |ROL Rotate Left                              |Bitwise Instructions  |ROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Absolute     |ROL $4400       |$2E    |3    |6   |ROL Rotate Left                              |Bitwise Instructions  |ROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Absolute,X   |ROL $4400,X     |$3E    |3    |7   |ROL Rotate Left                              |Bitwise Instructions  |ROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.|
|Accumulator  |ROR A           |$6A    |1    |2   |ROR Rotate Right                             |Bitwise Instructions  |ROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Zero Page    |ROR $44         |$66    |2    |5   |ROR Rotate Right                             |Bitwise Instructions  |ROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Zero Page,X  |ROR $44,X       |$76    |2    |6   |ROR Rotate Right                             |Bitwise Instructions  |ROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Absolute     |ROR $4400       |$6E    |3    |6   |ROR Rotate Right                             |Bitwise Instructions  |ROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Absolute,X   |ROR $4400,X     |$7E    |3    |7   |ROR Rotate Right                             |Bitwise Instructions  |ROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.|
|Relative     |BPL #$44        |$10    |2    |2   |BPL Branch on Plus                           |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BMI #$44        |$30    |2    |2   |BMI Branch on Minus                          |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BVC #$44        |$50    |2    |2   |BVC Branch on Overflow Clear                 |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BVS #$44        |$70    |2    |2   |BVS Branch on Overflow Set                   |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BCC #$44        |$90    |2    |2   |BCC Branch on Carry Clear                    |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BCS #$44        |$B0    |2    |2   |BCS Branch on Carry Set                      |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BNE #$44        |$D0    |2    |2   |BNE Branch on Not Equal                      |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Relative     |BEQ #$44        |$F0    |2    |2   |BEQ Branch on Equal                          |Branch Instructions   |Conditional jump counting from the next statement. Operator 0 - 127 jump forward, operator 128-255 jump backward. |
|Immediate    |CMP #$44        |$C9    |2    |2   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Zero Page    |CMP $44         |$C5    |2    |3   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Zero Page,X  |CMP $44,X       |$D5    |2    |4   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Absolute     |CMP $4400       |$CD    |3    |4   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Absolute,X   |CMP $4400,X     |$DD    |3    |4   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Absolute,Y   |CMP $4400,Y     |$D9    |3    |4   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|(Indirect,X) |CMP ($44,X)     |$C1    |2    |6   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|(Indirect),Y |CMP ($44),Y     |$D1    |2    |5   |CMP Compare Accumulator                      |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Immediate    |CPX #$44        |$E0    |2    |2   |CPX Compare X Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Zero Page    |CPX $44         |$E4    |2    |3   |CPX Compare X Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Absolute     |CPX $4400       |$EC    |3    |4   |CPX Compare X Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Immediate    |CPY #$44        |$C0    |2    |2   |CPY Compare Y Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Zero Page    |CPY $44         |$C4    |2    |3   |CPY Compare Y Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Absolute     |CPY $4400       |$CC    |3    |4   |CPY Compare Y Register                       |Compare Instructions  |Compare sets processor flags as if a subtraction had been carried out. If the accumulator and the compared value are equal, the result of the subtraction is zero and the Zero (Z) flag is set. If the accumulator is equal or greater than the compared value, the Carry (C) flag is set.|
|Zero Page    |BIT $44         |$24    |2    |3   |BIT Test Bits                                |Compare Instructions  |BIT sets the Z flag as though the value in the address tested were ANDed with the accumulator. The N and V flags are set equal to bits 7 and 6 respectively of the value in the tested address.|
|Absolute     |BIT $4400       |$2C    |3    |4   |BIT Test Bits                                |Compare Instructions  |BIT sets the Z flag as though the value in the address tested were ANDed with the accumulator. The N and V flags are set equal to bits 7 and 6 respectively of the value in the tested address.|
|Implied      |CLC             |$18    |1    |2   |CLC Clear Carry                              |Flag Instructions     |Clear flag in status register|
|Implied      |SEC             |$38    |1    |2   |SEC Set Carry                                |Flag Instructions     |Set flag in status register|
|Implied      |CLI             |$58    |1    |2   |CLI Clear Interrupt                          |Flag Instructions     |Clear flag in status register|
|Implied      |SEI             |$78    |1    |2   |SEI Set Interrupt                            |Flag Instructions     |Set flag in status register|
|Implied      |CLD             |$D8    |1    |2   |CLD Clear Decimal                            |Flag Instructions     |Clear flag in status register|
|Implied      |SED             |$F8    |1    |2   |SED Set Decimal                              |Flag Instructions     |Set flag in status register|
|Implied      |CLV             |$B8    |1    |2   |CLV Clear Overflow                           |Flag Instructions     |Clear flag in status register|
|Absolute     |JMP $5597       |$4C    |3    |3   |JMP Jump                                     |Jump Instructions     |JMP loads the program counter with the absolute address, or the address stored at the memory location of the indirect address. Program execution proceeds from the new program counter value.|
|Indirect     |JMP ($5597)     |$6C    |3    |5   |JMP Jump                                     |Jump Instructions     |JMP loads the program counter with the absolute address, or the address stored at the memory location of the indirect address. Program execution proceeds from the new program counter value.|
|Absolute     |JSR $5597       |$20    |3    |6   |JSR Jump Saving Return                       |Jump Instructions     |JSR pushes the address-1 of the next operation to the stack before transferring the value of the argument to the program counter. JSR behaves just like a JMP, but saves the return address to the stack first, thus creating a subroutine. Subroutines are normally terminated by an RTS instruction.|
|Implied      |RTS             |$60    |1    |6   |RTS Return to Saved                          |Jump Instructions     |RTS pulls the top two bytes off the stack (low byte first) and transfers them to the program counter. The program counter is incremented by one and then execution proceeds from there. RTS is typically used in combination with a JSR which saves the return address-1 to the stack.|
|Implied      |RTI             |$40    |1    |6   |RTI Return from Interrupt                    |Jump Instructions     |RTI retrieves the Processor Status byte and Program Counter from the stack in that order. Interrupts push the program counter first and then the processor status. Unlike RTS, the return address on the stack is the actual address rather than the address-1.|
|Immediate    |ADC #$44        |$69    |2    |2   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Zero Page    |ADC $44         |$65    |2    |3   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Zero Page,X  |ADC $44,X       |$75    |2    |4   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Absolute     |ADC $4400       |$6D    |3    |4   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Absolute,X   |ADC $4400,X     |$7D    |3    |4   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Absolute,Y   |ADC $4400,Y     |$79    |3    |4   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|(Indirect,X) |ADC ($44,X)     |$61    |2    |6   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|(Indirect),Y |ADC ($44),Y     |$71    |2    |5   |ADC Add with Carry                           |Math Instructions     |ADC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the addition is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to add without the carry.|
|Immediate    |SBC #$44        |$E9    |2    |2   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Zero Page    |SBC $44         |$E5    |2    |3   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Zero Page,X  |SBC $44,X       |$F5    |2    |4   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Absolute     |SBC $4400       |$ED    |3    |4   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Absolute,X   |SBC $4400,X     |$FD    |3    |4   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Absolute,Y   |SBC $4400,Y     |$F9    |3    |4   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|(Indirect,X) |SBC ($44,X)     |$E1    |2    |6   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|(Indirect),Y |SBC ($44),Y     |$F1    |2    |5   |SBC Subtract with Carry                      |Math Instructions     |SBC behavior depends on the state of the decimal flag. In decimal mode, the values upon which the subtraction is performed are interpreted as packed BCD (Binary Coded Decimal). There is no way to subtract without the carry. The carry works as an inverse borrow. i.e., to subtract, first set the carry. If the carry is cleared by the operation, a borrow has occurred.|
|Immediate    |LDA #$44        |$A9    |2    |2   |LDA Load Accumulator                         |Memory Instructions   |Take the operand for calculation immediate.            |
|Zero Page    |LDA $44         |$A5    |2    |3   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as zero page address.             |
|Zero Page,X  |LDA $44,X       |$B5    |2    |4   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as zero page address plus X.           |
|Absolute     |LDA $4400       |$AD    |3    |4   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as address.             |
|Absolute,X   |LDA $4400,X     |$BD    |3    |4   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as address plus X.             |
|Absolute,Y   |LDA $4400,Y     |$B9    |3    |4   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as address plus Y.             |
|(Indirect,X) |LDA ($44,X)     |$A1    |2    |6   |LDA Load Accumulator                         |Memory Instructions   |Take the operand plus X as zero page address.          |
|(Indirect),Y |LDA ($44),Y     |$B1    |2    |5   |LDA Load Accumulator                         |Memory Instructions   |Take the operand as zero page address, add Y to the contents.              |
|Immediate    |LDX #$44        |$A2    |2    |2   |LDX Load X Register                          |Memory Instructions   |Take the operand for calculation immediate.            |
|Zero Page    |LDX $44         |$A6    |2    |3   |LDX Load X Register                          |Memory Instructions   |Take the operand as zero page address.             |
|Zero Page,Y  |LDX $44,Y       |$B6    |2    |4   |LDX Load X Register                          |Memory Instructions   |Take the operand as zero page address plus Y.            |
|Absolute     |LDX $4400       |$AE    |3    |4   |LDX Load X Register                          |Memory Instructions   |Take the operand as address.             |
|Absolute,Y   |LDX $4400,Y     |$BE    |3    |4   |LDX Load X Register                          |Memory Instructions   |Take the operand as address plus Y.             |
|Immediate    |LDY #$44        |$A0    |2    |2   |LDY Load Y Register                          |Memory Instructions   |Take the operand for calculation immediate.     |
|Zero Page    |LDY $44         |$A4    |2    |3   |LDY Load Y Register                          |Memory Instructions   |Take the operand as zero page address.     |
|Zero Page,X  |LDY $44,X       |$B4    |2    |4   |LDY Load Y Register                          |Memory Instructions   |Take the operand as zero page address plus X.       |
|Absolute     |LDY $4400       |$AC    |3    |4   |LDY Load Y Register                          |Memory Instructions   |Take the operand as address.      |
|Absolute,X   |LDY $4400,X     |$BC    |3    |4   |LDY Load Y Register                          |Memory Instructions   |Take the operand as address plus X.      |
|Zero Page    |STA $44         |$85    |2    |3   |STA Store Accumulator                        |Memory Instructions   |Take the operand as zero page address.    |
|Zero Page,X  |STA $44,X       |$95    |2    |4   |STA Store Accumulator                        |Memory Instructions   |Take the operand plus X as zero page address. |
|Absolute     |STA $4400       |$8D    |3    |4   |STA Store Accumulator                        |Memory Instructions   |Take the operand as address.      |
|Absolute,X   |STA $4400,X     |$9D    |3    |5   |STA Store Accumulator                        |Memory Instructions   |Take the operand as address plus X.      |
|Absolute,Y   |STA $4400,Y     |$99    |3    |5   |STA Store Accumulator                        |Memory Instructions   |Take the operand as address plus Y.      |
|(Indirect,X) |STA ($44,X)     |$81    |2    |6   |STA Store Accumulator                        |Memory Instructions   |Take the operand plus X as zero page address.       |
|(Indirect),Y |STA ($44),Y     |$91    |2    |6   |STA Store Accumulator                        |Memory Instructions   |Take the operand as zero page address, add Y to the contents.       |
|Zero Page    |STX $44         |$86    |2    |3   |STX Store X Register                         |Memory Instructions   |Take the operand as zero page address. |
|Zero Page,Y  |STX $44,Y       |$96    |2    |4   |STX Store X Register                         |Memory Instructions   |Take the operand as zero page address plus Y.     |
|Absolute     |STX $4400       |$8E    |3    |4   |STX Store X Register                         |Memory Instructions   |Take the operand as address.   |
|Zero Page    |STY $44         |$84    |2    |3   |STY Store Y Register                         |Memory Instructions   |Take the operand as zero page address.   |
|Zero Page,X  |STY $44,X       |$94    |2    |4   |STY Store Y Register                         |Memory Instructions   |Take the operand as zero page address plus X.   |
|Absolute     |STY $4400       |$8C    |3    |4   |STY Store Y Register                         |Memory Instructions   |Take the operand as address.  |
|Zero Page    |DEC $44         |$C6    |2    |5   |DEC Decrement Memory                         |Memory Instructions   |Take the operand as zero page address. |
|Zero Page,X  |DEC $44,X       |$D6    |2    |6   |DEC Decrement Memory                         |Memory Instructions   |Take the operand as zero page address plus X.     |
|Absolute     |DEC $4400       |$CE    |3    |6   |DEC Decrement Memory                         |Memory Instructions   |Take the operand as address. |
|Absolute,X   |DEC $4400,X     |$DE    |3    |7   |DEC Decrement Memory                         |Memory Instructions   |Take the operand as address plus X.     |
|Zero Page    |INC $44         |$E6    |2    |5   |INC Increment Memory                         |Memory Instructions   |Take the operand as zero page address. |
|Zero Page,X  |INC $44,X       |$F6    |2    |6   |INC Increment Memory                         |Memory Instructions   |Take the operand as zero page address plus X.     |
|Absolute     |INC $4400       |$EE    |3    |6   |INC Increment Memory                         |Memory Instructions   |Take the operand as address. |
|Absolute,X   |INC $4400,X     |$FE    |3    |7   |INC Increment Memory                         |Memory Instructions   |Take the operand as address plus X. |
|Implied      |TAX             |$AA    |1    |2   |TAX Transfer A to X                          |Register Instructions |     |
|Implied      |TAY             |$A8    |1    |2   |TAY Transfer A to Y                          |Register Instructions |     |
|Implied      |TXA             |$8A    |1    |2   |TXA Tranfer X to A                           |Register Instructions |     |
|Implied      |TYA             |$98    |1    |2   |TYA Transfer Y to A                          |Register Instructions |     |
|Implied      |DEX             |$CA    |1    |2   |DEX Decrement X                              |Register Instructions |     |
|Implied      |DEY             |$88    |1    |2   |DEY Decrement Y                              |Register Instructions |     |
|Implied      |INX             |$E8    |1    |2   |INX Increment X                              |Register Instructions |     |
|Implied      |INY             |$C8    |1    |2   |INY Increment Y                              |Register Instructions |     |
|Implied      |PHA             |$48    |1    |3   |PHA Push Accumulator                         |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.|
|Implied      |PHP             |$08    |1    |3   |PHP Push Processor Status                    |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.|
|Implied      |TXS             |$9A    |1    |2   |TXS Transfer X to Stack Pointer              |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.|
|Implied      |PLA             |$68    |1    |4   |PLA Pull Accumulator                         |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.The "PULL" operations are known as "POP" on most other microprocessors.|
|Implied      |TSX             |$BA    |1    |2   |TSX Transfer Stack Pointer to X              |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.|
|Implied      |PLP             |$28    |1    |4   |PLP Pull Processor Status                    |Stack Instructions    |The stack is always on page $01 ($0100-$01FF) and works top down. i.e., when you push to the stack the stack pointer is decremented. When you pull from the stack the stack pointer is incremented.The "PULL" operations are known as "POP" on most other microprocessors.|
|Implied      |BRK             |$00    |1    |7   |BRK Break                                    |Other Instructions    |BRK sets the B flag, and then generates a forced interrupt. The Interrupt flag is ignored and the CPU goes through the normal interrupt process. In the interrupt service routine, the state of the B flag can be used to distinguish a BRK from a standard interrupt.BRK causes a non-maskable interrupt and increments the program counter by one. |
|Implied      |NOP             |$EA    |1    |2   |NOP No Operation                             |Other Instructions    |A NOP takes 2 machine cycles to execute, but it has no effect on any register, memory location, or processor flag. Thus, it takes up time and space but performs no operation.|
